<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + TS</title>
  </head>
  <body>
    <canvas id="main_canvas"></canvas>
  </body>
  <style>
    #main_canvas {
      width: 800px;
      height: 600px;
    }
  </style>
  <script id="vertex_shader" type="x-shader/x-vertex">
    #version 300 es
    in vec2 a_position;

    uniform vec2 u_resolution; // (canvas.width, canvas.height)

    void main() {
      gl_Position =  vec4(a_position, 0.0, 1.0);
    }
  </script>

  <script id="fragment_shader" type="x-shader/x-fragment">
    #version 300 es
    precision mediump float;

    out vec4 fragColor;

    uniform vec2 u_resolution;
    uniform float u_time;

    void main() {
      fragColor = vec4(vec3((sin(u_time) + 1.0), (cos(u_time) + 1.0), (sin(u_time) * cos(u_time) + 1.0)) / 2.0, 1.0);
    }
  </script>

  <script async type="module">
    import {
      transpile,
      ScriptTarget,
    } from "https://esm.sh/typescript@5.6.3?target=esnext";
    import { minify } from "https://esm.sh/terser@5.36.0?target=esnext";

    // esnext-polyfill
    Uint8Array.prototype.toBase64 ??= function () {
      return btoa(Array.from(this, (v) => String.fromCharCode(v)).join(""));
    };

    for (const { type, textContent } of document.getElementsByTagName(
      "script"
    )) {
      if (type !== "text/typescript" || !textContent) {
        continue;
      }

      const js = transpile(textContent, {
        target: ScriptTarget.ESNext,
      });

      const { code } = await minify(js, {
        module: true,
      });

      await import(
        `data:text/javascript;base64,${new TextEncoder()
          .encode(code)
          .toBase64()}`
      );
    }
  </script>

  <script type="text/typescript">
    const assertNonNullable = <T = unknown>(
      ref: T | null | undefined,
      logError?: string
    ): T => {
      if (ref == null) {
        logError && console.error(logError);
        throw new Error(`Assertion Failed for ${ref}`);
      }

      return ref;
    };

    const resizeCanvasToDisplaySize = (canvas: HTMLCanvasElement) => {
      const toCssPixelsRatio = window.devicePixelRatio;

      const displayWidth = Math.floor(canvas.clientWidth * toCssPixelsRatio);
      const displayHeight = Math.floor(canvas.clientHeight * toCssPixelsRatio);

      // Render buffer size
      canvas.width = displayWidth;
      canvas.height = displayHeight;
    };

    const showWebGLInfo = (gl: WebGLRenderingContext) => {
      console.log("=====================================");
      console.log("WebGL environment info");
      console.log("OpenGL Version: " + gl.getParameter(gl.VERSION));
      console.log(
        "Shading Language Version: " + gl.getParameter(gl.SHADING_LANGUAGE_VERSION)
      );
      console.log("Vendor: " + gl.getParameter(gl.VENDOR));
      console.log("=====================================");
    };

    /**
     * Load shader and returns compiled result.
     */
    const createShader = (
      gl: WebGLRenderingContext,
      type: GLenum,
      sourceTxt: string
    ) => {
      const shader = gl.createShader(type);
      if (!shader) {
        console.error("Error: No available shader in this environment.");
        return null;
      }
      gl.shaderSource(shader, sourceTxt);
      gl.compileShader(shader);

      const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!success) {
        // Failed to compile shader.
        console.error("Error: Failed to compile shader source.");
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }

      return shader;
    };

    /**
     * Create program, attach and link shaders to it.
     */
    const createProgram = (
      gl: WebGLRenderingContext,
      vertexShader: WebGLShader,
      fragmentShader: WebGLShader
    ) => {
      const program = gl.createProgram();

      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      const success = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!success) {
        console.error("Error: Failed to link program.");
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }

      return program;
    };
    function getNow() {
      return performance.now() * 0.001;
    }

    function main() {
      /**
       * create WebGL context
       */
      const canvas = assertNonNullable(
        document.getElementById("main_canvas") as HTMLCanvasElement | null
      );
      resizeCanvasToDisplaySize(canvas);

      const gl = canvas.getContext("webgl2"); // webgl version 1 (OpenGL ES 1.0)
      if (!gl) {
        throw new Error("Error: No available shader in this environment.");
      }
      showWebGLInfo(gl);

      // create shader program
      const vertexShaderSource = document.getElementById('vertex_shader').textContent.trim();
      const vertexShader = assertNonNullable(
        createShader(gl, gl.VERTEX_SHADER, vertexShaderSource),
        "vertexShader"
      );
      const fragmentShaderSource = document.getElementById('fragment_shader').textContent.trim();
      const fragmentShader = assertNonNullable(
        createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource),
        "fragmentShader"
      );
      const program = assertNonNullable(
        createProgram(gl, vertexShader, fragmentShader)
      );

      // clip space -> pixel space
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      // clear canvas
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.clear(gl.DEPTH_BUFFER_BIT);

      // activate created shader programs
      gl.useProgram(program);

      // create uniforms
      const resUniformLoc = gl.getUniformLocation(program, "u_resolution");
      gl.uniform2f(resUniformLoc, gl.canvas.width, gl.canvas.height);

      const timeUniformLoc = gl.getUniformLocation(program, "u_time");
      const startTime = getNow();
      gl.uniform1f(timeUniformLoc, startTime);

      // create attributes
      const positionAttrLoc = gl.getAttribLocation(program, "a_position"); // look up where the vertex data needs to go.
      gl.enableVertexAttribArray(positionAttrLoc);

      // set geometry
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

      const renderScale = 1.0;
      // prettier-ignore
      const positions = new Float32Array([
        -renderScale, -renderScale,
         renderScale, -renderScale,
        -renderScale,  renderScale,
         renderScale,  renderScale
      ]);

      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      gl.vertexAttribPointer(
        positionAttrLoc,
        2 /** size */,
        gl.FLOAT /** type */,
        false /**normalize */,
        0 /** stride */,
        0 /** offset */
      );

      function update() {
        requestAnimationFrame(() => {
          render({
            gl: gl as WebGL2RenderingContext,
            startTime,
            timeUniformLoc,
          });
          return update();
        });
      }

      update();
    }

    interface RenderContext {
      gl: WebGL2RenderingContext;
      startTime: number;
      timeUniformLoc: WebGLUniformLocation | null;
    }
    function render({ gl, timeUniformLoc, startTime }: RenderContext) {
      gl.uniform1f(timeUniformLoc, getNow() - startTime);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.flush();
    }

    window.onload = main;
  </script>
</html>
